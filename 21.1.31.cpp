e#define _CRT_SECURE_NO_WARNINGS 1

/*1.问题描述：
（1）、（2）两个地方分别输出多少？
（3）、（4）两个地方分别输出多少？*/
//#include <stdio.h>
//void test1(int arr[])    //传数组相当于是传指针，指针大小为---4
//{
//    printf("%d\n", sizeof(arr));//(2)---4
//}
//void test2(char ch[])
//{
//    printf("%d\n", sizeof(ch));//(4)---4
//}
//int main()
//{
//    int arr[10] = { 0 };
//    char ch[10] = { 0 };
//    printf("%d\n", sizeof(arr));//(1)---40
//    printf("%d\n", sizeof(ch));//(3)----10
//    test1(arr);
//    test2(ch);
//    return 0;
//}


/*2.问题描述：a,b,c,d的值为多少*/
//#include <stdio.h>
//int main()
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    i = a++ && ++b && d++;                                  //由于a是第一个是零为假，后面就不再进行运算了   //a--1  b--2  c--3  d--4
//    //i = a++||++b||d++;                                    //到b这里为2是真，则其后面的运算不再进行        //a--1  b--3  c--3  d--4
//    printf("a = %d\nb = %d\nc = %d\nd = %d\n", a, b, c, d); 
//    return 0;
//}


/*3.问题描述：设计一个小程序来判断当前机器的字节序*/
//#include<stdio.h>
//int check_sys()
//{
//	int i =0x00000001;     
//	char* p = (char *)&i;   //让它只能访问一个字节的内容
//	return *p;
//}
//int main()
//{
//	if (check_sys() == 1)
//	{
//		//把一个数据的低位字节序的内容，存放在低地址处
//		//            高位字节的内容，存放在高位地址处
//		printf("小端\n");   //1在小端内存存储的十六进制----------01 00 00 00
//	}
//	else
//	{
//		//把一个数据的低位字节序的内容，存放在高地址处
//                    //高位字节的内容，存放在低位地址处
//		printf("大端\n");   //1在大端内存存储的十六进制----------00 00 00 01
//	}
//	return 0;
//}


/*4.问题描述：输出什么？*/
//#include <stdio.h>
//int main()
//{
//    char a = -1;
//    //1000 0000 0000 0000 0000 0000 0000 0001 -----原码
//    //1111 1111 1111 1111 1111 1111 1111 1110 -----反码
//    //1111 1111 1111 1111 1111 1111 1111 1111 -----补码
//    //发生截断
//    //1111 1111  ----a
//    //由于要打印整形（%d）格式，所以发生整形提升，前面补充符号位
//    //1111 1111 1111 1111 1111 1111 1111 1111 -----补码
//    //1111 1111 1111 1111 1111 1111 1111 1110 -----反码
//    //1000 0000 0000 0000 0000 0000 0000 0001 -----原码
//    //a那打印就是-1
//
//    signed char b = -1;
//    unsigned char c = -1;
//    //1000 0000 0000 0000 0000 0000 0000 0001 -----原码
//    //1111 1111 1111 1111 1111 1111 1111 1110 -----反码
//    //1111 1111 1111 1111 1111 1111 1111 1111 -----补码
//    //发生截断
//    //1111 1111  ----c
//    //由于要打印整形（%d）格式，所以发生了整形提升，前面补充符号位,但c是无符号数，所以前面补0
//    //由于是正数-----补码==反码==原码
//    //0000 0000 0000 0000 0000 0000 1111 1111 
//    printf("a=%d,b=%d,c=%d", a, b, c); //a= -1  b= -1 c= 255
//    return 0;
//
//}


/*5.问题描述：输出什么？*/
//#include <stdio.h>
//int main()
//{
//    char a = -128;
//    //1000 0000 0000 0000 0000 0000 1000 0000 -----原码
//    //1111 1111 1111 1111 1111 1111 0111 1111 -----反码
//    //1111 1111 1111 1111 1111 1111 1000 0000 -----补码
//    //截断
//    //1000 0000 ----a
//    //由于要打印无符号整形（%u）格式，所以发生整形提升，前面补充符号位
//    //1111 1111 1111 1111 1111 1111 1000 0000 -----补码==反码==原码  
//    printf("%u\n", a);   //打印的值-----4294967168‬
//    return 0;
//}


/*6.问题描述：输出什么？*/
//#include <stdio.h>
//int main()
//{
//    char a = 128;
//    //1000 0000 0000 0000 0000 0000 1000 0000 -----原码==反码==补码
//    //截断
//    //1000 0000
//    //因为要打印的是无符号整数（%u）格式，所以发生整形提升，前面补充符号位
//    //无符号数的补码==反码==原码  
//    //1111 1111 1111 1111 1111 1111 1000 0000 -----补码==反码==原码  
//    printf("%u\n", a);  //打印的值-----4294967168‬
//    return 0;
//}


/*7.问题描述：输出什么？*/
//#include<stdio.h>
//int main()
//{
//	int i = -20;
//	//1000 0000 0000 0000 0000 0000 0001 0100 -----原码
//	//1111 1111 1111 1111 1111 1111 1110 1011 -----反码
//	//1111 1111 1111 1111 1111 1111 1110 1100 -----补码
//	unsigned int j = 10;
//	//1111 1111 1111 1111 1111 1111 1110 1100 -----①
//	//0000 0000 0000 0000 0000 0000 0000 1010 -----②          10的原码==反码==补码
//	//①+②得到
//	//1111 1111 1111 1111 1111 1111 1111 0110 -----补码
//	//1111 1111 1111 1111 1111 1111 1111 0101 -----反码
//	//1000 0000 0000 0000 0000 0000 0000 1010 -----源码
//	printf("%d\n", i + j);    打印的值----10
//	return 0;
//}


/*8.问题描述：会发生什么情况*/
//#include<stdio.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)        //无符号整形恒大于0,所以会死循环
//	{                               //当i变成-1时，把有符号数转变位无符号数为32个1然后一直死循环下棋
//                                  //1000 0000 0000 0000 0000 0000 0000 0001 -----原码
//                                  //1111 1111 1111 1111 1111 1111 1111 1110 -----反码
//                                  //1111 1111 1111 1111 1111 1111 1111 1111 -----补码 -1对应的无符号数
//		printf("%d\n", i);
//	}
//	return 0;
//}


/*9.问题描述：输出什么？*/
//#include<stdio.h>
//#include<string.h>
//int main()
//{
//    char a[1000];
//    int i;
/*a是字符型数组，strlen找的是第一次出现尾零（即值为0）的位置。考虑到a[i]其实是字符型，
如果要为0，则需要 - 1 - i的低八位要是全0，也就是问题简化成了“寻找当 - 1 - i的结果第一次出现低八位全部为0的情况时，
i的值”（因为字符数组下标为i时第一次出现了尾零，则字符串长度就是i）。只看低八位的话，此时 - 1相当于255，所以i == 255的时候，
- 1 - i（255 - 255）的低八位全部都是0，也就是当i为255的时候，a[i]第一次为0，所以a[i]的长度就是255了。*/
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;      //-128~127
//    }
//    printf("%d", strlen(a));   //strlen(a)----255
//    return 0;
//}

/*10.问题描述：输出什么？*/
//#include <stdio.h>
//unsigned char i = 0;
//int main()
//{
//    for (i = 0; i <= 255; i++)      //无符号整形恒大于0,所以会死循环
//    {
//        printf("hello world\n");
//    }
//    return 0;
//}


/*11.问题描述：输出什么？*/
//#include <stdio.h>
//#include<string.h>
//int main()
//{
//	int n = 9;
//	float* p = (float*)&n;
//	printf("%d\n", n);     //9
//	printf("%f\n", *p);    //0.000000
//
//	*p = 9.0;
//	printf("%d\n", n);     //1091567616
//	printf("%f\n", *p);   //9.0000000 
//}


/*12.问题描述：输出什么？*/
//#include <stdio.h>
//int main()
//{
//    unsigned char a = 200;
//    unsigned char b = 100;
//    unsigned char c = 0;
//    c = a + b;
//    printf("%d %d", a + b, c); //a+b----300  c----44
//    return 0;
//}
//printf在传入参数的时候如果是整形会默认传入四字节，所以a + b的结果是用一个四字节的整数接收的，不会越界。
//而c已经在c = a + b这一步中丢弃了最高位的1，所以只能是300 - 256得到的44了。
//※由于printf是可变参数的函数，所以后面参数的类型是未知的，所以甭管你传入的是什么类型，
//printf只会根据类型的不同将用两种不同的长度存储。其中8字节的只有long long、float和double（注意float会处理成double再传入），
//其他类型都是4字节。所以虽然a + b的类型是char，实际接收时还是用一个四字节整数接收的。
//另外，读取时， % lld、 % llx等整型方式和 % f、 % lf等浮点型方式读8字节，其他读4字节。