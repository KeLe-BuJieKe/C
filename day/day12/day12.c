#define _CRT_SECURE_NO_WARNINGS 1


//1.如下代码输出结果是多少
//#include<stdio.h>
//#include<stdlib.h>
//int f(int x, int y)
//{
//	return (x & y) + ((x ^ y) >> 1);
//}
//int main()
//{
//	int result = f(2, 4);
//	printf("%d\n", result);			//3
//	system("pause");
//	return 0;
//}



//2.下面的程序运行结果是
//#include<stdio.h>
//void fun(int x, int y, int* c, int* d)
//{
//	*c = x + y;
//	*d = x - y;
//}
//int main()
//{
//	int a = 4, b = 3, c = 0, d = 0;
//	fun(a, b, &c, &d);
//
//	printf("%d %d\n", c, d);		//7   1
//	return 0;
//}



//算法题
/*一个整形数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出两个只出现一次的数字。
例如：数组为{1,3,5,7,1,3,5,9}，找出7和9*/
#include<stdio.h>
int* singleNumber(int* nums, int numsSize)
{
    if (nums == NULL || numsSize < 2)
    {
        return NULL;
    }
    //按找上题思路
    //1.首先把所有数异或，得到两个只出现一次数异或的结果
    int ret = 0;
    for (int i = 0; i < numsSize; ++i)
    {
        //任何数与0异或为任何数 0 ^ n => n
        //得到两个只出现一次数异或的结果
        ret ^= nums[i];
    }

    //2.我们开始想方法将它们分离
    //2.1首先找出ret二进制第一个二进制1是第几位(M)
    //说明x1和x2的第M位二进制不相同，一个为0，一个为1
    int M = 0;
    while (M < 32)
    {
        /*假设  x1为5   x2为3
                0101    0011
                5^3==0110
                不可能会出现ret=0的情况，因为如果要出现这种情况，必须x1与x2相同
                异或的俩个数一定至少会有一位二进制为1，找到这个1所在第几位
        */
        if ((ret >> M) & 1)      //如果找到有一位为1，则退出循环，否则M++
        {
            break;
        }
        else
        {
            ++M;
        }
    }
    //2.2然后我们去数组中分离出x1和x2
    //将M位为0的分为一组，为1的分为一组
    int x1 = 0, x2 = 0;
    for (int j = 0; j < numsSize; ++j)
    {
        if ((nums[j] >> M) & 1)   //nums[j]二进制位中的第M位为1的一组
        {
            //每个第M位为1的nums成员与x1异或得到x1
            x1 ^= nums[j];
        }
        else                //nums[j]二进制位中的第M位为0的一组
        {
            //每个第M位为0的nums成员与x2异或得到x2
            x2 ^= nums[j];
        }
    }
    int* retArray = (int*)malloc(sizeof(int) * 2);
    retArray[0] = x1;
    retArray[1] = x2;
    return retArray;
}



//智力题
/*一群人开舞会，每个人头上都戴着一顶帽子。帽子只有黑白俩种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。
主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。
于是在开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有噼噼啪啪打耳光的声音响起。问有多少人戴着黑帽子？*/


/*假设有A、B、C三个人，第一次关灯前,A、B、C三个人都看到了其它俩人戴了黑帽子
所以在第1次关灯时：
没有一人打耳光，此时，拿C为例，C此时的想法应为，C看到A与B戴黑帽子，所以第一轮没有打自己耳光，
并且以为A看到了B戴黑帽子，B看到了A戴黑帽子，所以互相都没打耳光，C自己现在就不确定是不是黑帽子，A、B、C的想法相同
到了第2次关灯时：
我们继续拿C为例，此时C发现A、B都没有打耳光，此时C就知道了，A与B都分别看到了两个戴黑帽子的人，所以没有打，自己也是看到了如此，
此时C就知道，自己戴的也是黑帽子
到了第3次关灯时：
A、B、C就打起了耳光

总结发现：关几次灯，就有多少戴黑帽子的人。
*/