1.二叉树的最大深度
思路：通过后序遍历判断左右子树的深度，在选出左右子树大的那个+1，
得到父亲节点的深度。


2.单值二叉树
思路：通过前序遍历，判断根节点与左右节点的值是否相等，相等则继续进行
前序遍历。


3.相同的树
思路：通过前序遍历进行判断，如果相同位置的节点的值相同，则继续判断，
若不同则返回false。


4.翻转二叉树
思路：通过后序遍历，先翻转左子树的节点，在翻转右子树的节点，在把左子树与右子树交换。


5.对称二叉树
思路一：
通过前序遍历，判断左子树的左孩子与右子树的右孩子和左子树的右孩子与右子树的左孩子
的值是否相同，相同则继续递归，否则返回false。

思路二：
依靠前面的3和4两题的思路，翻转左子树，再判断左子树与右子树是否相同，相同则是对称二叉树。


6.二叉树的前序遍历
//迭代法----- 待补


7.二叉树的中序遍历
//迭代法----- 待补


8.二叉树的后序遍历
//迭代法----- 待补


9.另一个树的子树
思路：根据3的思路，我们通过前序遍历每个节点再判断以该节点为根的子树与subroot树进行判断是否相同
如果相同则证明subroot是该树的子树。


10.读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树，再对二叉树进行中序遍历


11.平衡二叉树
思路一：通过前序遍历来判断每个节点左子树与右子树的深度之差<2,小于则继续递归，否则返回false。
时间复杂度为：O(N^2)

思路二：通过后序遍历，先判断左子树是否平衡，再判断右子树，并把高度通过指针的形式传回。
时间复杂度：O(N)
